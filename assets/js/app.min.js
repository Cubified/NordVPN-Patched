const API_URL = "https://api.nordvpn.com",
   DAY_SECONDS = 86400,
   LOCATION_EXPIRATION = 300,
   WEIGHT_DISTANCE = .7,
   WEIGHT_LOAD = .3,
   EXPONENT_DISTANCE = .5,
   EXPONENT_LOAD = 7,
   UNREASONABLE_PENALTY = 9999,
   DISTANCE_SPREAD = 1e-6,
   LOAD_SPREAD = 1e-6,
   DEFAULT_DISTANCE = 0,
   DEFAULT_LOAD = 0,
   COEFFICIENT_KILOMETERS = 1.609344,
   COEFFICIENT_NAUTICAL_MILES = .8684,
   FULL_LOAD = 100,
   UNIT_KILOMETERS = "K",
   UNIT_NAUTICAL_MILES = "N",
   NVPN_EVENT_CONNECT = "nvpn.event.connect",
   NVPN_EVENT_DISCONNECT = "nvpn.event.disconnect",
   NVPN_EVENT_SIGNOUT = "nvpn.event.signout",
   NVPN_EVENT_SETTINGS_WEBRTC = "nvpn.event.settings.webrtc",
   NVPN_EVENT_SETTINGS_CYBERSEC = "nvpn.event.settings.cybersec",
   NVPN_EVENT_USER_REFRESH = "nvpn.event.user.refresh",
   NVPN_EVENT_USER_EXPIRED = "nvpn.event.user.expired",
   NVPN_EVENT_USER_UPGRADED = "nvpn.event.user.upgraded",
   NVPN_EVENT_SHOW_SERVERS = "nvpn.event.show.servers",
   NAME_STRING_STANDARD_VPN_SERVERS = "Standard VPN servers",
   HTTPS_PROXY_PORT_REGULAR = 89,
   HTTPS_PROXY_PORT_CYBERSEC = 90,
   ALTERNATIVE_DOMAIN_COLLECTION = ["https://zwyr157wwiu6eior.com", "https://boi9osyg1uwtyafn.com", "https://x9fnzrtl4x8pynsf.com", "https://icpsuawn1zy5amys.com", "https://api.nordvpn.com"];
! function() {
   "use strict";

   function e(e, t, n, r) {
      t.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|file|chrome-extension):/), t.imgSrcSanitizationWhitelist(/^\s*((https?|ftp|file|blob|chrome-extension):|data:image\/)/), n.setKeyPrefix("nvpn."), r.setDomainCollection(ALTERNATIVE_DOMAIN_COLLECTION), e.when("/", {
         controller: "HomepageController",
         templateUrl: "templates/welcome.html",
         controllerAs: "vm"
      }).when("/signin", {
         controller: "SigninController",
         templateUrl: "templates/sign-in.html",
         controllerAs: "vm"
      }).when("/disconnected", {
         controller: "DisconnectedController",
         templateUrl: "templates/disconnected.html",
         controllerAs: "vm"
      }).when("/connected", {
         controller: "ConnectedController",
         templateUrl: "templates/connected.html",
         controllerAs: "vm"
      }).when("/settings", {
         controller: "SettingsController",
         templateUrl: "templates/settings.html",
         controllerAs: "vm"
      }).when("/settings/cybersec", {
         controller: "SettingsController",
         templateUrl: "templates/settings.cybersec.html",
         controllerAs: "vm"
      }).when("/settings/webrtc", {
         controller: "SettingsController",
         templateUrl: "templates/settings.webrtc.html",
         controllerAs: "vm"
      }).when("/signout", {
         controller: "SignoutController",
         templateUrl: "templates/sign-in.html",
         controllerAs: "vm"
      }).when("/location", {
         controller: "LocationController",
         templateUrl: "templates/location.html",
         controllerAs: "vm"
      }).when("/location/:flag", {
         controller: "LocationController",
         templateUrl: "templates/location.html",
         controllerAs: "vm"
      }).when("/error", {
         controller: "ErrorController",
         templateUrl: "templates/error.html",
         controllerAs: "vm"
      }).when("/error/loc", {
         controller: "ErrorController",
         templateUrl: "templates/error.loc.html",
         controllerAs: "vm"
      }).when("/expired", {
         controller: "ErrorController",
         templateUrl: "templates/expired.html",
         controllerAs: "vm"
      }).when("/showServers/:flag",{
	  	controller: "ShowServersController",
		templateUrl: "templates/showServers.html",
		controllerAs: "vm"
	  }).when("/connectTo/:domain",{
	  	controller: "CustomConnectionController",
		templateUrl: "templates/redirect.html",
		controllerAs: "vm"
	  }).otherwise({
         redirectTo: "/"
      })
   }

   function t(e, t, n, r, i, o, a) {
      e.nvpn = chrome.extension.getBackgroundPage().app, e.settings = n.settings || {}, angular.equals({}, e.settings) && a.webrtc_enable(), e.connection = n.connection || {}, e.globals = n.globals || {}, e.globals.currentUser && t.path("/disconnected"), e.$on("$locationChangeStart", function(r, a, s) {
         if("/error/loc" !== t.path()) {
            const r = e.nvpn.util.proxy.read();
            if(!r.underNVPNControl) return angular.equals({}, e.connection) || (n.tmpConnection = e.connection), n.connection = e.connection = {}, n.$apply(), e.globals.currentUser && e.nvpn.util.icon.enable(), t.path("/error/loc");
            r.controlledByNVPN && n.tmpConnection && (n.connection = e.connection = n.tmpConnection, delete n.tmpConnection, n.$apply(), e.nvpn.util.icon.active()), r.controllableByNVPN && n.tmpConnection && (n.connection = e.connection = {}, delete n.tmpConnection, n.$apply(), e.globals.currentUser && e.nvpn.util.icon.enable())
         }
         const u = !["/", "/signin", "/expired", "/error", "/error/loc", "/settings"].includes(t.path());
         u && e.globals.currentUser && (["/settings", "/settings/cybersec", "/settings/webrtc", "/signout"].includes(t.path()) || o.isExpired() && (o.isOutdated() && i.refreshUser(o.getCurrentUser()), t.path("/expired"))), u && !e.globals.currentUser && t.path("/")
      }), e.$on("$viewContentLoaded", r.onViewContentLoaded), r.initialize()
   }
   angular.module("nvpn", ["ngRoute", "ngStorage"]).config(e).run(t), e.$inject = ["$routeProvider", "$compileProvider", "$localStorageProvider", "DomainServiceProvider"], t.$inject = ["$rootScope", "$location", "$localStorage", "EventListenerService", "EventDispatcherService", "CurrentUserService", "SettingsService"]
}(),
function() {
   "use strict";
   angular.module("nvpn").provider("DomainService", function() {
      let e = [];
      return {
         setDomainCollection: function(t) {
            e = t
         },
         $get: ["DomainAlternativeService", function(t) {
            return {
               getAlternative: function(n) {
                  return t.getAlternative(e.slice(), n)
               }
            }
         }]
      }
   })
}(),
function() {
   "use strict";

   function e(e, t) {
      function n(n, r) {
         return t.getAlternative(n, r).then(t => (e.setAlternative(t.domain), {
            domain: t.domain
         }))
      }
      return {
         getAlternative: function(r, i) {
            return t.resolveAlternative(e.getAlternative(), i).catch(() => {
               if(e.getAlternative()) {
                  const t = r.indexOf(e.getAlternative());
                  r.splice(t, 1), e.unsetAlternative()
               }
               return n(r, i)
            })
         }
      }
   }
   angular.module("nvpn").factory("DomainAlternativeService", e), e.$inject = ["DomainCacheService", "DomainResolverService"]
}(),
function() {
   "use strict";

   function e(e) {
      function t(t) {
         e.alternative = t, e.$apply()
      }
      return {
         setAlternative: t,
         getAlternative: function() {
            return e.alternative || null
         },
         unsetAlternative: function() {
            t(null)
         }
      }
   }
   angular.module("nvpn").factory("DomainCacheService", e), e.$inject = ["$localStorage"]
}(),
function() {
   "use strict";

   function e(e, t) {
      function n(e, i) {
         const o = e.shift();
         return void 0 !== o ? r(o, i).catch(() => n(e, i)) : t.reject("no internet connection or available domains")
      }

      function r(n, r) {
         return n ? ("/" === r.substring(0, 1) && (r = r.substring(1)), e.head(`${n}/${r}`, {
            cache: !1
         }).then(() => ({
            domain: n
         }))) : t.reject("no domain name provided")
      }
      return {
         getAlternative: function(e, t) {
            return n(e, t)
         },
         resolveAlternative: r
      }
   }
   angular.module("nvpn").factory("DomainResolverService", e), e.$inject = ["$http", "$q"]
}(), angular.module("nvpn").factory("FlashService", ["$rootScope", function(e) {
   function t(e, t, n) {
      return {
         message: e,
         type: t,
         keepAfterLocationChange: n
      }
   }
   return function() {
      function t() {
         const t = e.flash;
         t && (t.keepAfterLocationChange ? t.keepAfterLocationChange = !1 : delete e.flash)
      }
      e.$on("$locationChangeStart", function() {
         t()
      })
   }(), {
      success(n, r) {
         e.flash = t(n, "success", r)
      },
      error(n, r) {
         e.flash = t(n, "error", r)
      },
      warning(n, r) {
         e.flash = t(n, "warning", r)
      }
   }
}]), angular.module("nvpn").factory("AuthenticationService", ["$rootScope", "$http", "$localStorage", "DomainService", function(e, t, n, r) {
   function i(e, n, r, i) {
      let o, a;
      return t.get(`${e}/token/token/${n}`).then(n => {
         o = n.data, a = {
            nToken: o.token
         };
         const i = sha512(sha512(o.salt + r) + o.key);
         return t.get(`${e}/token/verify/${o.token}/${i}`, {
            headers: a
         })
      }).then(() => t.get(`${e}/user/loginv2`, {
         headers: a
      })).then(e => ({
         success: !0,
         user: e.data,
         token: o.token
      })).catch(() => ({
         success: !1,
         message: "Username or password incorrect."
      })).then(i)
   }

   function o() {
      e.globals = n.globals = {}, n.$apply()
   }
   return {
      signin: function(e, t, n) {
         return r.getAlternative(`/token/token/${e}`).then(r => i(r.domain, e, t, n))
      },
      signout: function() {
         o()
      },
      setCredentials: function(t, r, i) {
         e.globals = {
            currentUser: {
               username: t,
               token: r,
               password: i
            }
         }, n.globals = e.globals, n.$apply()
      },
      clearCredentials: o
   }
}]), angular.module("nvpn").service("CurrentUserService", ["$rootScope", function(e) {
   this.getCurrentUser = function() {
      return e.globals.currentUser
   }, this.getUsername = function() {
      return this.getCurrentUser().username
   }, this.getPassword = function() {
      return this.getCurrentUser().password
   }, this.isExpired = function() {
      return(this.getCurrentUser().expiredAt || 0) <= Date.now()
   }, this.isOutdated = function() {
      return(this.getCurrentUser().updatedAt || 0) <= Date.now() - 6e4
   }
}]), angular.module("nvpn").service("DistanceService", ["$rootScope", function(e) {
   function t(e, t, n, r, i) {
      const o = Math.PI * e / 180,
         a = Math.PI * n / 180,
         s = t - r,
         u = Math.PI * s / 180;
      let c = Math.sin(o) * Math.sin(a) + Math.cos(o) * Math.cos(a) * Math.cos(u);
      return c = Math.acos(c), c = 180 * c / Math.PI, c = 60 * c * 1.1515, UNIT_KILOMETERS === i && (c *= COEFFICIENT_KILOMETERS), UNIT_NAUTICAL_MILES === i && (c *= COEFFICIENT_NAUTICAL_MILES), Math.round(c)
   }
   const n = this;
   let r = {};
   return n.getMeasurementUnit = function() {
      return "K"
   }, n.distance = function(i) {
      if(!i || !i.id) return NaN;
      if(!r[i.id]) {
         const o = e.globals.currentUser.latitude,
            a = e.globals.currentUser.longitude,
            s = i.location.lat,
            u = i.location.long,
            c = n.getMeasurementUnit();
         r[i.id] = t(o, a, s, u, c)
      }
      return r[i.id] || !1
   }, n.resetDistanceMap = function() {
      r = {}
   }, n
}]), angular.module("nvpn").service("ProxyServersService", ["$rootScope", "DistanceService", function(e, t) {
   this.findBestServer = function(e) {
      if(e.length < 1) return;
      const t = this.getLoads(e),
         n = this.getDistances(e),
         r = this.getScores(e, t, n).sort((e, t) => e.score < t.score ? -1 : e.score > t.score ? 1 : 0),
         i = [r[0]];
      for(let e = 1; e < r.length && r[0].score === r[e].score; e++) i.push(r[e]);
      const o = i[Math.floor(Math.random() * i.length)];
      for(let t = 0; t < e.length; t++)
         if(e[t].id === o.id) return e[t]
   }, this.getLoads = function(e) {
      const t = [];
      return e.forEach(function(e) {
         this.push(e.load)
      }, t), t
   }, this.getDistances = function(e) {
      const n = [];
      return e.forEach(function(e) {
         this.push(t.distance(e))
      }, n), n
   }, this.getScores = function(t, n, r) {
      const i = Math.max(...n),
         o = Math.min(...n),
         a = Math.max(...r),
         s = Math.min(...r),
         u = a - s || 1e-6,
         c = i - o || 1e-6,
         l = e.globals.currentUser.countryCode || "",
         f = [];
      return t.forEach(function(e) {
         const t = {
            id: e.id
         };
         t.score = this.getScore(e, c, u, s, o, l), f.push(t)
      }, this), f
   }, this.getScore = function(e, n, r, i, o, a) {
      const s = t.distance(e) || 0,
         u = e.load || 0,
         c = a.toLowerCase() === e.flag.toLowerCase() ? 0 : 1;
      if(100 === u) return 9999;
      const l = (s - i) / r,
         f = (u - o) / n;
      return .7 * Math.pow(l, .5) + .3 * Math.pow(f, 7) + c
   }
}]), angular.module("nvpn").factory("LocationCacheService", ["$localStorage", function(e) {
   return {
      load: function() {
         const t = Date.now(),
            n = e.locations;
         return !(!n || t > n.timestamp) && n.value
      },
      save: function(t) {
         const n = Date.now();
         return e.locations = {
            value: t,
            timestamp: n + 1e3 * LOCATION_EXPIRATION
         }, e.$apply(), t
      }
   }
}]), angular.module("nvpn").factory("LocationProviderService", ["$q", "$http", "LocationCacheService", "DomainService", function(e, t, n, r) {
   function i(e) {
      return t.get(e).then(function(e) {
         const t = e.data.filter(function(e) {
            const t = e.categories.map(e => e.name.toLowerCase()).includes(NAME_STRING_STANDARD_VPN_SERVERS.toLowerCase()),
               n = e.features.proxy;
            return t && n
         });
         return n.save(t), t
      })
   }
   const o = "/server";
   return {
      getList: function() {
         const t = n.load();
         return t ? e.resolve(t) : r.getAlternative(o).then(e => i(`${e.domain}${o}`))
      }
   }
}]), angular.module("nvpn").factory("LocationService", ["LocationProviderService", function(e) {
   return {
      getList: function() {
         return e.getList().then(function(e) {
            return e.sort((e, t) => e.country.localeCompare(t.country)).reduce(function(e, t) {
               return e[t.flag] = e[t.flag] || {
                  country: t.country,
                  flag: String(t.flag).toLowerCase(),
                  servers: []
               }, e[t.flag].servers.push(t), e
            }, {})
         })
      }
   }
}]), angular.module("nvpn").constant("httpsProxyPorts", {
   REGULAR: 89,
   CYBERSEC: 90
}).service("ProxyService", ["$rootScope", "httpsProxyPorts", function(e, t) {
   this.enable = function(n) {
      const r = {
         mode: "fixed_servers",
         rules: {
            singleProxy: {
               host: n.domain,
               port: e.settings.cybersec ? t.CYBERSEC : t.REGULAR,
               scheme: "https"
            },
            bypassList: ["<local>"]
         }
      };
      chrome.proxy.settings.set({
         value: r,
         scope: "regular"
      })
   }, this.disable = function() {
      chrome.proxy.settings.clear({
         scope: "regular"
      })
   }
}]), angular.module("nvpn").service("SettingsService", ["$rootScope", "$localStorage", "EventDispatcherService", function(e, t, n) {
   this.cybersec_enable = function() {
      e.settings = angular.extend(e.settings, {
         cybersec: !0
      }), this._applyStorage(), n.settings(NVPN_EVENT_SETTINGS_CYBERSEC, !0)
   }, this.cybersec_disable = function() {
      e.settings = angular.extend(e.settings, {
         cybersec: !1
      }), this._applyStorage(), n.settings(NVPN_EVENT_SETTINGS_CYBERSEC, !0)
   }, this.webrtc_enable = function() {
      e.settings = angular.extend(e.settings, {
         webrtc: !0
      }), this._applyStorage(), n.settings(NVPN_EVENT_SETTINGS_WEBRTC, !0)
   }, this.webrtc_disable = function() {
      e.settings = angular.extend(e.settings, {
         webrtc: !1
      }), this._applyStorage(), n.settings(NVPN_EVENT_SETTINGS_WEBRTC, !1)
   }, this._applyStorage = function() {
      t.settings = e.settings, t.$apply()
   }
}]), angular.module("nvpn").factory("EventDispatcherService", ["$rootScope", function(e) {
   return {
      connect: function() {
         e.$broadcast(NVPN_EVENT_CONNECT)
      },
      disconnect: function() {
         e.$broadcast(NVPN_EVENT_DISCONNECT)
      },
      signout: function() {
         e.$broadcast(NVPN_EVENT_SIGNOUT)
      },
      settings: function(t, n) {
         e.$broadcast(t, n)
      },
      refreshUser: function(t) {
         return e.$broadcast(NVPN_EVENT_USER_REFRESH, t)
      },
	  showServers: function(t){
	  	e.$boardcast(NVPN_EVENT_SHOW_SERVERS,t);
	  }
   }
}]), angular.module("nvpn").factory("EventListenerService", ["$rootScope", "$location", "$localStorage", "EventDispatcherService", "ProxyService", "AuthenticationService", function(e, t, n, r, i, o) {
   return {
      initialize: function() {
         e.$on(NVPN_EVENT_DISCONNECT, function(t, n) {
            e.nvpn.util.icon.enable(), r.settings(NVPN_EVENT_SETTINGS_WEBRTC, !1), chrome.extension.sendRequest({
               type: "activeChanged",
               connection: e.connection
            })
         }), e.$on(NVPN_EVENT_SIGNOUT, function(t, n) {
            e.nvpn.util.icon.disable(), r.settings(NVPN_EVENT_SETTINGS_WEBRTC, !1), chrome.extension.sendRequest({
               type: "activeChanged",
               connection: e.connection
            })
         }), e.$on(NVPN_EVENT_CONNECT, function(t, n) {
            e.nvpn.util.icon.active();
			r.settings(NVPN_EVENT_SETTINGS_WEBRTC, e.settings.webrtc);
			chrome.extension.sendRequest({
               type: "activeChanged",
               connection: e.connection
            });
			chrome.runtime.sendMessage({
               type: "nvpn.proxy.enabled"
            });
         }), e.$on(NVPN_EVENT_SETTINGS_WEBRTC, function(t, n) {
			/*
			 * CAUSE OF CRASH:
			 * chrome.privacy.network.webRTCIPHandlingPolicy.set is broken
			 */
//            e.nvpn.util.webrtc.disable();
			if(e.connection.connected && n){
//				e.nvpn.util.webrtc.enable();
			}
         }), e.$on(NVPN_EVENT_SETTINGS_CYBERSEC, function(t, n) {
            e.connection.connected && i.enable(e.connection.server)
         }), e.$on(NVPN_EVENT_USER_REFRESH, function(t, r) {
            o.signin(r.username, r.password, function(t) {
               t.success && (e.globals.currentUser.token = t.token, e.globals.currentUser.expiredAt = Date.now() + 1e3 * t.user.expires, e.globals.currentUser.updatedAt = Date.now(), e.globals.currentUser.expires = Math.ceil(t.user.expires / DAY_SECONDS), n.globals.currentUser = e.globals.currentUser, n.$apply(), e.globals.currentUser.expiredAt <= Date.now() ? e.$broadcast(NVPN_EVENT_USER_EXPIRED) : e.$broadcast(NVPN_EVENT_USER_UPGRADED))
            })
         }), e.$on(NVPN_EVENT_USER_EXPIRED, function(e) {
            i.disable(), r.disconnect(), t.path("/expired")
         }), e.$on(NVPN_EVENT_USER_UPGRADED, function(e) {
            t.path("/disconnected")
         })
      },
      onViewContentLoaded: function(e) {
         jQuery(".SVG--inline").each(function() {
            const e = jQuery(this),
               t = e.attr("id"),
               n = e.attr("class"),
               r = e.attr("src");
            jQuery.get(r, r => {
               let i = jQuery(r).find("svg");
               void 0 !== t && (i = i.attr("id", t)), void 0 !== n && (i = i.attr("class", n)), i = i.removeAttr("xmlns:a").attr("preserveAspectRatio", "xMidYMid meet"), e.replaceWith(i)
            }, "xml")
         })
      }
   }
}]), angular.module("nvpn").controller("HomepageController", ["$rootScope", "$location", function(e, t) {
   e.globals.currentUser && t.path("/disconnected")
}]), angular.module("nvpn").controller("SigninController", ["$rootScope", "$location", "FlashService", "AuthenticationService", "$localStorage", function(e, t, n, r, i) {
   const o = this;
   o.signin = function() {
      o.dataLoading = !0, o.spinner = !0, r.signin(o.username, o.password, a => {
         a.success ? (r.setCredentials(a.user.username, a.token, o.password), e.globals.currentUser.expiredAt = Date.now() + 1e3 * a.user.expires, e.globals.currentUser.updatedAt = Date.now(), e.globals.currentUser.expires = Math.ceil(a.user.expires / DAY_SECONDS), e.globals.currentUser.countryCode = a.user.country_code, e.globals.currentUser.latitude = a.user.latitude, e.globals.currentUser.longitude = a.user.longitude, i.globals.currentUser = e.globals.currentUser, i.$apply(), e.nvpn.util.icon.enable(), t.path("/disconnected")) : n.error(a.message)
      }).catch(() => {
         t.path("/error")
      }).finally(() => {
         o.dataLoading = !1, o.spinner = !1
      })
   }, o.dataLoading = !1, o.spinner = !1, e.globals.currentUser && t.path("/disconnected")
}]), angular.module("nvpn").filter('searchFilter',()=>{
	return (serverList)=>{
		return serverList;
	};
}), angular.module("nvpn").controller("ShowServersController", ["$rootScope", "$scope", "$routeParams", "$localStorage", "$location", "LocationService", "ProxyService", "ProxyServersService", "EventDispatcherService", function(e,s,t,n,r,i,o,a) {
	let self = this;
	s.setInputScope = (scope)=>{
		self.searchString = scope.searchString;
	};
	s.getSearchString = ()=>{
		let result = [];
		let searchString = (typeof self.searchString === 'string' ? self.searchString.toLowerCase() : '');
		angular.forEach(s.serverList,(item)=>{
			let categoriesString = '';
			item.categories.forEach((e)=>{
				categoriesString += e.name.toLowerCase();
			});
			if(categoriesString.indexOf(searchString) > -1){
				result.push(item);
			}
		});
		console.log(s.serverList);
		s.searchedList = result;
	};
	const flag = t.flag;
	i.getList().then(t => {
		let json = t[flag],
			servers = json.servers;
		s.country = json.country;
		let sortedServers = servers.sort((a,b)=>{
			let int1 = parseInt(a.name.split('#')[1]),
				int2 = parseInt(b.name.split('#')[1]);
			if(int1 > int2){
				return 1;
			} else if(int1 < int2){
				return -1;
			}
			return 0;
		});
		s.serverList = sortedServers;
		s.searchedList = sortedServers;
		s.flag = flag;
		s.flagLowercase = flag.toLowerCase();
	});
}]), angular.module("nvpn").controller("CustomConnectionController", ["$rootScope","$scope","$location","$localStorage","$routeParams","ProxyService","EventDispatcherService",function($rootScope,$scope,$location,$localStorage,$routeParams,proxy,eds){
	for(let flag in $rootScope.servers){
		$rootScope.servers[flag].servers.forEach((server)=>{
			if(server.domain === $routeParams.domain){
				$rootScope.json = server;
				$rootScope.json.country = $rootScope.json.name;
			}
		});
	}
	$rootScope.connection = {
		connected: 1,
		server: $rootScope.json || {}
	};

	proxy.enable($routeParams);
	$localStorage.connection = $rootScope.connection;
	$localStorage.$apply();
	eds.connect();
	$location.path("/connected");
}]), angular.module("nvpn").controller("DisconnectedController", ["$rootScope", "$location", "$localStorage", "LocationProviderService", "ProxyService", "ProxyServersService", "EventDispatcherService", function(e, t, n, r, i, o, a) {
   const s = this;
   s.connecting = !1, s.connect = function() {
      s.connecting = !0, s.spinner = !0, r.getList().then(r => {
         const s = o.findBestServer(r);
         i.enable(s), n.connection = e.connection = {
            connected: !0,
            server: s
         }, n.$apply(), a.connect(), t.path("/connected")
      }).catch(() => {
         t.path("/error")
      }).finally(() => {
         s.connecting = !1, s.spinner = !1
      })
   }, s.currentUser = e.globals.currentUser, s.spinner = !1, e.connection.connected && t.path("/connected")
}]), angular.module("nvpn").controller("SignoutController", ["$rootScope", "$location", "AuthenticationService", "ProxyService", "$localStorage", "EventDispatcherService", function(e, t, n, r, i, o) {
   n.signout(), r.disable(), i.connection = e.connection = {}, i.$apply(), o.signout(), t.path("/")
}]), angular.module("nvpn").controller("LocationController", ["$rootScope", "$routeParams", "$localStorage", "$location", "LocationService", "ProxyService", "ProxyServersService", "EventDispatcherService", function(e, t, n, r, i, o, a, s) {
   const u = this;
   if(u.servers = {}, u.isEmptyObject = function(e) {
         return angular.equals({}, e)
      }, u.spinner = !0, i.getList().then(t => {
         u.servers = e.servers = t
      }).catch(() => {
         r.path("/error")
      }).finally(() => {
         u.spinner = !1
      }), t.flag) {
      const i = a.findBestServer(e.servers[t.flag.toUpperCase()].servers);
      o.disable(), n.connection = e.connection = {}, n.$apply(), s.disconnect(), o.enable(i), n.connection = e.connection = {
         connected: !0,
         server: i
      }, s.connect(), r.path("/connected")
   }
}]), angular.module("nvpn").controller("ConnectedController", ["$rootScope", "$location", "ProxyService", "$localStorage", "EventDispatcherService", function(e, t, n, r, i) {
   const o = this;
   o.connection = e.connection, o.disconnect = function() {
      n.disable(), r.connection = e.connection = {}, r.$apply(), i.disconnect(), t.path("/disconnected")
   }, o.currentUser = e.globals.currentUser, e.connection.connected || t.path("/disconnected")
}]), angular.module("nvpn").controller("SettingsController", ["$rootScope", "SettingsService", function(e, t) {
   const n = this;
   n.settings = e.settings, n.service = t
}]), angular.module("nvpn").controller("ErrorController", ["$rootScope", function(e) {}]), angular.module("nvpn").filter("locationFilter", function() {
   return function(e, t) {
      if(!e) return e;
      if(!t) return e;
      const n = ("" + t).toLowerCase(),
         r = {};
      return angular.forEach(e, function(e, t) {
         -1 !== ("" + e.country).toLowerCase().indexOf(n) && (r[t] = e)
      }), r
   }
}), angular.module("nvpn").directive("backButton", ["$window", function(e) {
   return {
      restrict: "A",
      link: function(t, n, r) {
         n.bind("click", function() {
            e.history.back()
         })
      }
   }
}]);
